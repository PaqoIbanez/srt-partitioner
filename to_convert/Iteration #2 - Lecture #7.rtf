{\rtf1\ansi\deff0
\margl1800\margr1800\margb1440\margt1440\deflang1033\lndscpsxn
{\colortbl;
}
{\fonttbl;
{\f0 Arial}
}
{\pard  \line \par}
{\b\fs36 [00:00:00] 0701 Start\b0}
{\pard  \line \par}
{In today's lecture I want to talk about state machines. State machines can be very useful to write shorter and more concise contracts, both on chain and off-chain. And their support for state machines in the Plutus libraries that is higher level and builds on top of the lower level mechanisms we have seen so far. }
{\pard  \line \par}
{\b\fs36 [00:00:30] 0702 Commit schemes\b0}
{\pard  \line \par}
{As a running example for today, I want to implement a little game played between Alice and Bob. It's a bit like a rock paper scissors, but even simpler because there are only two options. So Alice and Bob both have two options. They can either play zero or one. And if they play it while being physically in the same room, it would be played just like rock paper scissors. So at the same time they raised their hand and there's one gesture for zero and one gesture for one.}
{\pard  \line \par}
{And depending on what they play, one of them wins. So if they both use the same gesture, both choose zero or both choose one, then Alice wins. And if the choices are different than Bob wins. Now let's imagine that Alice and Bob can't meet in person, but they still want to play the game. So they decide to play it via email or snail mail, doesn't matter. Of course, we will later implemented on the blockchain using Plutus. But how could that work? So Alice can send a mail with her choice, let's say zero to Bob. But this of course gives a very unfair advantage to Bob because now he opens Alice's mail and see if she picked zero and he can simply reply sending one and he wins.}
{\pard  \line \par}
{And of course, if Alice instead picks one, Bob can simply choose zero. So Bob would always win at least if he's unfair. So what can we do about that? And there's a very clever trick that's often used in cryptographic protocols. And that's about humid schemes. So the idea is that Alice doesn't reveal her choice to Bob, but she commits to it so that she later can change her mind.}
{\pard  \line \par}
{And, one way to make that work is using hash functions. I mean, hashes are all over the place in the blockchain world. I mean, we have seen that, for example, addresses script addresses are just the hash of the Plutus core script and a we've seen lots of examples of using public key hashes and so on. And what hash functions are? }
{\pard  \line \par}
{There are so called one way functions. So it's difficult or impossible given a hash to reconstruct the original document or the original byteString that was hashed to this hash. So one way we could try to make this work is that instead of sending her choice to Bob, she instead send the hash of her choice to Bob. So she sends the hash of zero. Which is just some, I don't know, cryptic byteString. So now Bob sees this cryptic byteString and he has no idea whether Alice picked zero or one. So he maybe picked zero and there's no need for him to use a hash. So here can just send the zero in Kia text. And, so now Alice would have won, but maybe Bob doesn't believe her.}
{\pard  \line \par}
{So there's then one additional step that Alice has to send another message to Bob where she now sends her actual choice. And then what Bob has to do is he has to check whether hash of Alice's claim choice is indeed the hash he received earlier. And if it is, then he knows that Alice is not lying and that she indeed picked zero and that he lost.}
{\pard  \line \par}
{But if this hash doesn't match up, then he knows she's cheating or trying to cheat and he would win. And of course, if Alice instead picked one that would work exactly the same, except that the hash would be different. So this sounds promising, but there's one big problem with this, because in this game, there are only two choices, only zero and one.}
{\pard  \line \par}
{So there are only two possible hashes. They may look very cryptic to Bob the first time they play. But, I mean, sooner or later you noticed that he always sees one of these two hashes. And then he knows which choice Alice made. And that's almost as bad as if she directly sent her choice out in the open.}
{\pard  \line \par}
{But what we can do here is that Alice doesn't simply send the hash of zero, but that she first concatenates zero with some arbitrary byteString so called nonce that she picks. So the way this would work is first Alice picks a nonce, some arbitrary text. And then she sends the hash of the nonce and her choice. For example, zero to Bob, which is some other cryptic byteString.}
{\pard  \line \par}
{And now it's not always the same byteString, if you pick zero provided she always chooses some random unpredictable nonce. So Bob receives it and then it proceeds as before. So he sends his choice, for example, zero. And now in the third message, Alice has to not only reveal her original choice, but she has to send the nonce as well.}
{\pard  \line \par}
{So in this case, she would send the nonce and zero. And then Bob checks that hash of Alice's claimed nonce concatenated with zero is indeed the hash she originally received. And if it is, he knows he lost. And if it does not, then he knows she tried to cheat him. So this works very nicely and this is what we will try to implement in Plutus on Cardano.}
{\pard  \line \par}
{So first we'll use what we have seen so far and then we'll see how by using state machines, the code can be much clearer and much shorter. Now, what will this look like? So first Alice opens the game by posting the hash of a nonce combined with the choice she makes to play. So we have the hash.}
{\pard  \line \par}
{Then if Bob plays along, he will post his own choice. So Bob will play, and now we have the hash and Bob's choice, let's call it C Bob. If at this point, Alice realizes that she has won, depending on Bob's choice, she can reveal her secret and the game ends and she has won. Let's assume that when Alice plays in Bob plays, they both put down certain amount of money.}
{\pard  \line \par}
{And in this scenario where Alice has won Alice gets Bob's claim and her own back. If however, after Bob made his move, Alice sees that she has lost, there's no need actually for her to do anything because she has lost anyway. So after a certain deadline has been reached. And Alice just doesn't reply. And then Bob claims his win.}
{\pard  \line \par}
{And there's another option that we haven't considered it, it could be that after Alice starts playing, Bob simply is not interested and doesn't reply. So in that case, there must be a way for Alice to get her own money back. And that's basically all the things that can happen. So the different stages of the game starts by Alice opening with the hash of the concatenation of a nonce in her move.}
{\pard  \line \par}
{Then if Bob doesn't reply, Alice gets her money back. If Bob does reply, he puts down his choice and then there are two possibilities again. Alice realizes she has won and she needs to prove it to Bob by revealing and she wins or she doesn't do anything and after some time has passed, Bob can claim the win.}
{\pard  \line \par}
{And he gets both Alice's at his own stake. So let's implement this in Plutus now. First, just using the techniques we already know about. }
{\pard  \line \par}
{\b\fs36 [00:09:15] 0703 Implementation without state machines\b0}
{\pard  \line \par}
{So let's look at the implementation, it's in the module even odd. And if you're wondering about that name, it's just because if the sum of the two choices of the two numbers that the players pick is even then the first player wins and if it's odd, the second player wins. Which is the same as what I said earlier, that if they agree, the first player wins and if they are different, the second player wins. And I called the first and second player first and second, instead of Alice and Bob here. So the data type game is used as a parameter for the contract.}
{\pard  \line \par}
{So G first and G second are the two players identified by their public key hashes. G stake is an integer that denotes the number of lovelace that are to be used as stake in the game by each player. And then there are two deadlines, play deadline and reveal deadline. So play deadline is by what time the second player has to make a move before the first player can claim back his stake. And the reveal deadline is in the case that the second player has made the move. How much time the first player has to claim victory by revealing his nonce. And finally, we have a token represented by its asset class. And this will be the same trick that I used last time for the oracle, that will be NFT in arbitrary NFT use to identify the right instance of the UTxO that we are using.}
{\pard  \line \par}
{So the idea is, again, similar to what we did with the oracle who use the datum of a UTxO sitting at the address of this contract, this script address of this contact to keep track of what has happened, where we are in the game.}
{\pard  \line \par}
{Then the type game choice. So that's just the two moves the players can make, zero or one. And, I derive equality in the normal Haskell sense and an ord instance, but unfortunately for the Plutus equivalence of eq and ord that's not possible. And I need eq for Plutus eq so I do that by hand in the usually way. So, I mean zero equals zero and one equals one and all other combinations are not equal.}
{\pard  \line \par}
{And for this to work with template Haskell, you have to put this inlinable pragma there as well for the equals operation. And game datum is what I will use as state for the contract. And byteString is the hash that the first player submits and maybe game choice is the move by the second player. It's a maybe because in the beginning, the second player hasn't yet moved.}
{\pard  \line \par}
{So then it will be nothing and once the second player has moved, it will be a just. And same thing I also need a Plutus equality for game datum. And just also the obvious one that two are equal if both components, the hash and the maybe game choice are equal. Now we come to the redeemer and for that, I also implemented the custom type that called game redeemer.}
{\pard  \line \par}
{And that corresponds to the transitions we saw in the diagram I drew just now. So, play is when the second player moves and as argument, it has a game choice. So the second player can play zero or one. So that will be play zero or play one. Reveal is for the case when the first player has won and must prove that by revealing its nonce.}
{\pard  \line \par}
{So the byteString argument here would be the nonce. We don't need to also provide the move that the first player made, because he will only reveal in the case he has won and we know what move makes him win. So that would be redundant and therefore I left it. And finally claim first and came. Second claim first is in the case when the second player doesn't make a move.}
{\pard  \line \par}
{So the first player can claim back his stake and came second is for the case that the first player doesn't reveal because he knows he has lost. So the second player can get his winnings. Then same helper function I use last time. That I think is for some reason missing from the Plutus libraries. So given a value extractor number of lovelaces content in it. And then similar last time I had oracle datum function, and now I did the same for game datum.}
{\pard  \line \par}
{So given an output of a transaction and some way to given a datum hash, maybe get the datum, give me a game datum. And it's the same as with oracle last time. So it's these three steps. First I get the try to get the data hash from the output, which may fail second year, use the second argument function to turn this hash into a data and value.}
{\pard  \line \par}
{And lastly, I try to pass this datum as a something from of type game datum. So that's exactly what I did for the oracle last time. Now we come to the core business logic in the make game validator function. The first argument here is the parameter of the game type that I just explained. The second and the third argument, somewhat of a nuisance.}
{\pard  \line \par}
{And I just need them due to the fact that as we have already discussed on Discord, it's not possible to use string literals to get byteStrings in Haskell that is compiled to Plutus core. And I want, string literals representing the zero choice and the one choice. So this will just be the byteString with the digit zero and the byteString with the digit one.}
{\pard  \line \par}
{But because I can't use string literals, I passed them in as auxiliary arguments we'll see how we pass them in later. Then the usual datum, redeemer and context. Let's look at some helper functions first. So info as before own input and own output also as before. So this should never fail because we are in the context of validating the usage of a UTxO. }
{\pard  \line \par}
{So there should always be own input the input via presently validating. Own output if you're in a case where we are not done yet, where the game isn't over. We want that there's a new UTxO carrying the NFT with the updated datum. So for that case, we will use this own output function and it checks all the outputs that go to the same address. And only succeeds if there's exactly one such. Output datum makes use of this game datum function that we defined earlier. And given the case where we have exactly one output to the same script address gives us the datum tries to gives us the datum. And that could fail or otherwise we return the datum. So check nonce is for the case that the first player has won and wants to prove it by revealing his nonce and improving that the hash submitted in the beginning of the game fits this nuance. }
{\pard  \line \par}
{So the first argument is the hash he submitted. The second argument is the nonce he now reveals. The third argument is the move that both players made. It's called C second here, move of the second player, but this function would only be involved or only be relevant in the case where the first player knows he has won, which is only the case when he made the same choice that the second player made.}
{\pard  \line \par}
{So I could just as well called at sea first in principle. And in order to do this check, I mean, how did the computation of the hash work where I take the nonce and concatenated with the choice. But the choice of course here is, is some abstract data type game choice, but in order to concatenate with the nonce I needed in byteString form. And the idea is, I just use this BS zero for the zero choice and BS one for the one choice.}
{\pard  \line \par}
{So this is just as conversion. And I called the byteString C first. So C second is of type game choice, but C first is of type byteString. And if the choice was zero, I'd take the byteString representing zero. If it was one, I take the bites strong representing one, then to compute the hash I take the nonce concatenated with this byteString and apply the sha2_256, a hash function to it.}
{\pard  \line \par}
{So this is the hash that I get giving this nonce then check is to make sure that that is indeed the hash, the first player committed in the first place. And finally, I haven't mentioned that before, but we now have this state token, this NFT that identifies the correct UTxO and the question is what happens to this NFT after the game is over and there is no UTxO at the game address anymore.}
{\pard  \line \par}
{And the way I've implemented. Now, I've wanted to go back to the first player. The first player needs to have it at the beginning in order to kick off the game and put the NFT into the correct UTxO. So I think it's, it's only reasonable to give it back to him in the end, no matter who won the game.}
{\pard  \line \par}
{So this just checks, there's a function called value paid to and gets the context or the info from the context. And pub key hash and then it basically adds up all the values that go to that pub key hash in some output of the transaction. So I want that, so this just means that the first player gets the token.}
{\pard  \line \par}
{So now we can look at the, at the conditions. There's one condition that applies to all cases simultaneously. And that is that the input I'm validating must be identified by the state token. So that's what I'm checking here. That the own input, the input I'm presently validating, contains the state token.}
{\pard  \line \par}
{And then what the, the rules, after that depend on the situation I'm in. The first situation is the one where the first player has moved. The second player is moving now. So this is the transaction where the second player moves and chooses to move C. So the datum, the second component must be nothing.}
{\pard  \line \par}
{Remember that just means that the second player hasn't moved to is moving now. And in this case, what do I have to check? I have to check that this move is indeed made by the second player. So he has to sign the transaction. This checks that the first player has put down the stake for the game. Then this checks that now in this transaction, the second player, it's his own stake.}
{\pard  \line \par}
{So in the output, we now have twice the G stake game. Then we know exactly what the datum of the output must be. It must be the same hash as before, but now the nothing is replaced by just C where C is exactly the move, the second player is making. Then the move has to happen before the first deadline. That's exactly the point of this first step by the play deadline until then the move must have happened.}
{\pard  \line \par}
{And finally, the NFT must be passed onto the new UTxO to identify that again. Okay, the second situation is both players have moved and the first player discovers that he has won. So in order to prove that and get the win winnings, he has to reveals his nonce. So in that case, it has to be signed by the first player.}
{\pard  \line \par}
{The nonce must indeed agree with the hash he submitted earlier. He must do this before the reveal deadline. The input must contain the stake of both players. And finally, what I just said, the NFT must go back to the first player. First case is second player hasn't moved yet and also doesn't move in the deadline.}
{\pard  \line \par}
{So the first player wants his stake back. So this must be signed by the first player. It must only happen after the deadline has passed. The first player has provided his stake and he must get the NFT back. And the last case is, both players have moved, but the first player has realized that he didn't win and therefore didn't reveal his nonce or he got disconnected or whatever, in any case, he missed the deadline.}
{\pard  \line \par}
{So in that case, the second player wins, but the second player must sign this transaction. So it must not happen before the deadline, he can only do that once the reveal deadline has passed to give the first play enough time to reveal the nonce if the first player won. We check again that the input, the consumed UTxO has the correct stake.}
{\pard  \line \par}
{So in this case, both players must have provided their stake. And even though the second player has won and gets the money, the NFT must go back to the first player. And that's all legitimate transitions we can have. So in all other cases, we don't validate, we fail validation. So now let's look at the rest of the on-chain code. As always, we define this helper type that just bundles information about what the datum and what the redeemer type are. }
{\pard  \line \par}
{Here we define the byteStrings we actually going to use for the two choices zero and one. This is completely arbitrary. I could pick any two byteString there. Typed game validator, it compiles de code as before. So it's parameterized now by game and these two byteStrings, this make validator function. So I have to apply all of them, but I just use these constants here. So now, I only left with this one game parameter as one would expect. And the usual boiler plate for validator and address. Now as preparation for the on-chain code, sorry for the off-chain code, we will always need to find the right UTxO. So the one that carries the NFT. So I write this helper function find game output that gets the game and then in the contract monad tries to find the UTxO. So it could fail, the UTxO or could not be there. So therefore maybe, and then I return the usual things, the reference and the output itself and additionally, the game datum. And that's called straightforward to implement.}
{\pard  \line \par}
{So first I get all the UTxOs at the game address. Then I use this find function. This is in data dot list. And it's more general, doesn't only work for lists, it works for more general containers of type T, but you can think lists. So it gets a predicate on elements and the list of As and returns a maybe A. }
{\pard  \line \par}
{And the logic is if it finds an element in the list that satisfies the predicate, it will return it as a just and otherwise it will return nothing. So if we do find even 1, 3, 5, 8, 11, 12. It will pick the first even number from the list just eight. But if I remove the even elements, then it will return nothing.}
{\pard  \line \par}
{So using this find. After we have all the UTxOs turn them into a list of pairs, then as F we take such a pair, ignore the reference, just take the o. And check whether this output contains our token. So this line, which by the way, happens in the maybe monad. Will... If it exists, find us the UTxO that contains the token. And then we use the earlier defined helper function game datum to get the datum to this UTxO and return the triple. Now there's a second helper function, wait until time has passed. The idea is it gets a POSIX time and then it waits until that POSIX time has passed and we are in the next slot. So how do I do that?}
{\pard  \line \par}
{I get the current slot, I just log it. Then I use something provided by the contract monad called await time which does what it says. So it gets a POSIX time and waits blocks the contract until the time has come. And then just to make sure that I'm in the next slot, I wait for one slot using wait N slots.}
{\pard  \line \par}
{And I just for information, ask for the now current slot and also log that. Okay, so now we have two contracts for the two players. One for the first player to play the game. The other one for the second player, second player plays the game. And with corresponding parameters first params and second params. So, first params we don't need the first player. The first player will be the owner of the wallet that invokes this contract, but we need the second and the other things we need to define the game, the stake and the two deadlines. Then we need the nonce that the first player wants to use to conceal his choice. And then the NFT which we split into currency symbol and token name. And finally the choice, the move that the player wants to make.}
{\pard  \line \par}
{So in this contract, first get our own public key hash. Then we can define the value of the game type. So we put our own public key hash as first player and then use the parameters we got from the first params. And for the token we just assemble the currency symbol and token name into an asset class.}
{\pard  \line \par}
{And this V value is just our stake that we must put into the . UTxO plus the NFT that we must put into the UTxO. C is our choice. Now we compute the hash that we must put there, our commitment to our choice. So we take the more nonce and concatenate it with, well, if you want to play zero. There's zero byteString, and otherwise the one byteString and hash the results.}
{\pard  \line \par}
{The constraints for the transaction are very simple. All we have to do is we must produce a script output at this address with the datum that contains the hash. We just computed nothing for the second player, because obviously the second player hasn't played yet. And the value we computed. And we wait for transaction and log a message.}
{\pard  \line \par}
{So now, the second player has a chance to move, but it must happen before this play deadline. So what we do now is first player is we wait until this deadline has passed. And then there are several cases. So we check whether we find UTxO containing the NFT, if we don't find it, then something has gone very wrong.}
{\pard  \line \par}
{That can't actually happen, because this can't just disappear. We know we just produce the UTxO at this address and all anybody else at the second player can do is, make a move, but that doesn't destroy the UTx... I mean, it's removed, UTxO that produces a new one at the same address again. So we should find it.}
{\pard  \line \par}
{There's no way we can not find it. But nevertheless, if that happens then... throwing an exception, but normally we will find it. So we have this triple the UTxO And the datum. And in this case, the second player hasn't moved. So the deadline has passed. The second player hasn't moved. So what we can do is we can invoke this claim first redeemer to get our stake back.}
{\pard  \line \par}
{So as constraints, we just say, we must spend this UTxO we found with this redeemer and as lookups we need to provide the UTxO. And we must provide the validator of the game. And in that case, we log that we reclaimed the stake. Second case is that the second player did move and they are then in turn again, two cases that the second player moved and won or that the second player moved and lost.}
{\pard  \line \par}
{So this is the case where the second player choose the same move that we played, so we won. And in the other case, the second player won and we can't do anything so we just don't do anything. But if we won, we must now reveal our nonce to get the winning. So we use the reveal nonce redeemer. And we must also submit this transaction before the deadline for revealing has passed. And we, again, need lookups, we again need to specify the UTxO and we must provide the gain validator. And then we submit and wait and have won. Now for the second player, the parameters are very similar, except that now we don't need to provide the second player because that's us.}
{\pard  \line \par}
{But the first player stake and the two deadlines as before currency, symbol and token name for the NFT as before. And the choice, the move we want to make. We don't need the nonce now because the nonce was only for the first player. Okay, so if we start by looking up our own public key hash and can then define the game value, similar to as what you did for the first player.}
{\pard  \line \par}
{And now we, try to find the UTxO that contains the NFT. So if we find it and... BS is the commitment of the first player, the hash. And nothing, because we haven't moved yet. So in that case, we found the game, so this is the most interesting case, but let's look at the second case that it's not like that.}
{\pard  \line \par}
{Well, in that case, we just didn't find the game where we can move, so we can't do anything. So it's enough to concentrate on this case. So if we found the game and now we want to make our move, so invoke the play redeemer. So token is the NFT, now V is the value that we must put in the new output. Remember if we do the play transaction, we must consume the existing UTxO and producing one at the same address.}
{\pard  \line \par}
{And, the old one should contain the stake that the first player put in. And now we must add our own stake and we must keep the NFT in there. And the NFT of course is also contained in the, in the input side already. So, what we must put in the output is, so X is just local variable here to, so that's the steak in lovelace. So we must into the output, put twice the stake and the NFT. C is our choice, let's look at the constraints first. So we must spend the existing UTxO with redeemer play our choice. Then we must create a new UTxO with the updated datum. So same BS, but now just C, just our move. And this V we computed, which now also contains our own stake in addition to the first player stake and the NFT. And we must do this before the deadline passes to make the play move. And we need lookups, so we must provide the UTxO. And because we are consuming script opportunity the validator, and because we are producing one, we need the script instance. Then we do the usual things.}
{\pard  \line \par}
{So we submit, we wait for confirmation, we log. Now it's the first player's turn again. So we wait until this reveal deadline has passed. And we, again, try to find the UTxO which will now or could now, be a different one. That's I called M prime So if we don't find an UTxO any more, that means that in the meantime, while were waiting, the first player revealed and won. }
{\pard  \line \par}
{So, in that case we have lost, we can't do anything. If we still do find the UTxO, it means the first player didn't reveal, which means either the first player left the game for whatever reason or he lost and couldn't reveal. In any case now we can claim the winning. So we must spend the UTxO we found. We must do this before and after the reveal deadline has passed, because until then the first players still would have time to, to make his revelation.}
{\pard  \line \par}
{And we must hand back the NFT to the first player. And as lookups, we again need this UTxO, and we must provide the validator. And we do the usual thing and log the message. And that's it, that's the two on-chain contracts. But now to make them more accessible, we defined schema, game schema which has two endpoints. One for the first player taking the first params. One for the second player taking the second params. And we define a contract called endpoints that offers the choice between these two endpoints. And no matter what is chosen, after that is then run it recursively again, offers less choice. And first and second is simply our first game in second game where we first block and wait for user input or external input to provide the parameters and then bind the contracts we defined earlier.}
{\pard  \line \par}
{And that concludes the first version of the game. That doesn't use state machines. Now let's test this using the emulator trace monad, So the code is in module test.}
{\pard  \line \par}
{And let's look first look at the test prime function, which is parameterized by two game choices. So the idea is that we'll run or simulate a game where the first player makes this choice and the second player makes that choice. And then in the test function, I just run all four combinations in sequence.}
{\pard  \line \par}
{And, as before with the oracle I'm using this run emulator trace IO prime variant, because I want to specify an initial distribution. And I just want to provide wallet one with this NFT. So, I just make up a currency symbol and some token name, I call it state token. And, of course, in a real scenario in the production code, we would have to generate this NFT, for example, using this mint contract from the currency use case, or also using our own contract that we discussed when we introduce minting policies.}
{\pard  \line \par}
{But, and if these are now not the focus of this lecture, so I just use this feature that I can conjure one out of thin air in this emulator trace configuration. Okay. So now let's look at the trace. So it takes these two parameters, the two choices, C1 and C2. I just locked some information that later in the output, it's easier to identify what was going on.}
{\pard  \line \par}
{And I start two instances of the endpoints contract one for wallet, one, one for wallet two h1 and h2 to lookup the two public key hashes of the two wallets. And now I define the parameters that they will use. So first player is first wallet, second player has The second wallet stake is five ADA deadline. The first deadline is after five slots, second deadline after 10 slots.}
{\pard  \line \par}
{this of course should be some random string in reality, but now I just fix one secret nonce. And, I used this token that I provided earlier as the NFT And of course the choice of the first place. Just see one parameter from here. And, the choice of the second player is C2. Okay. And with these definitions phase simple, I just called the h1 at the first endpoint on void one with these FP parameters I had just wait three slots and then I call the second endpoint for wallet two with the SP parameters that I defined here and wait another 10 slots.}
{\pard  \line \par}
{So by that time you should be in slot 13 or something to both deadlines should have been passed and there should have been enough time for everything to settle. And if we run this, okay, so I'm in module tests now. And if I invoke this test and then let's go through the output. So the first scenario is, that both play zero.}
{\pard  \line \par}
{So the first bullet should win. so here the first bullet, it creates the initial. UTxO with its stake and knocks this message that made them move. Now, the first wallet is waiting now the second fall, it kicks in and it looks for the UTxO or finds it and sees that it can make a move. So it makes it smooth zero.}
{\pard  \line \par}
{And now the first bullet sees this move and realizes that it has won because both have played the same move. So now the first file, it must reveal and that's that here and, has won. So the first wallet has won and we see in the final balances that wallet one does indeed have the state token back.}
{\pard  \line \par}
{This NFT and now has almost five, eight, or more than it started with the differences of course, due to transaction fees. And the second wallet, it has a bit more than five, eight, or less than at the beginning. So wallet one, one. Now the second case is what add one again, plays zero, but for the two plays one.}
{\pard  \line \par}
{So the beginning is the same. So the first wallet creates this. Initially UTxO, now with the second wallet again, finds the game and makes its move. But now the move is one. So now the first one that realizes that it has lost and doesn't do anything. So the second wallet detects it, that the first fall, it hasn't made a move and now invokes this claim second endpoint to get the money.}
{\pard  \line \par}
{So now if you look at the final balances, Situation is reversed again, wallet one, got the stake token back, but now wallet one has 500 or less and wallet two has five eight more than before. And the other two cases are more or less the same, just the other way round. So if it's one zero, then wallet two will win again.}
{\pard  \line \par}
{And if it's one, one, then wallet one give it again, so this all seems to work as expected.}
{\pard  \line \par}
{\b\fs36 [00:42:04] 0704 State machines\b0}
{\pard  \line \par}
{So what is the state machine? The state machine? first of all, normally it has nothing to do with blockchain particular. So it's just some sort of system you start in a certain state, and then there are one or more transitions to other states. And so you can transition from the initial state into this one or that one.}
{\pard  \line \par}
{And that goes on. So basically it's just a directed graph. And then there may also be some states that are special in that they're so-called final states from which they are no possible ways out anymore. No transitions that lead out of the final state. And, what does it have to do with blockchain and with our examples?}
{\pard  \line \par}
{So if we look again at the diagram we had earlier for how our game works, then we can consider that state machine. So the initial state would be this one here, where the first player has made the move and the state is basically characterized by the state owned by the hash. And in this state, there are two possible transitions, one where the second player plays. Bob place. And the second one where it doesn't play and the first player can reclaim. So all the notes in this diagram, cause point 2 states and all the errors, the edges of the graph correspond to transitions. And in particular, in the blockchain, the state machine will be represented by UTxO sitting at the state machine script address.}
{\pard  \line \par}
{And the state of the state machine would be the datum of the UTxO and the transition will be a transaction that consumes the current state. That's current. UTxO using a trend redeemer that characterizes the transition and then produces a new, UTxO at the same, address where the datum now reflects the new state.}
{\pard  \line \par}
{So that's the relation and that fits lots of situations very nicelly. And there's special support in the Plutus libraries to easily implement such state machines. And then we'll see when we use this approach that our code will be much shorter. The support for state machines is in package Plutus contract in the module Plutus contract state machine. And let's first look at what a state machine is.}
{\pard  \line \par}
{So a state machine is, has to type parameters S and I that stands for state and input and that corresponds to datum and redeemer. So in the actual implementation and the manifestation of the state machine on the blockchain S will be the datum type, and I will be the redeemer type. And, so a state machine is a record type with four fields.}
{\pard  \line \par}
{So the most important one probably is the transition that defines from which states using which transition you can change into another state. And this state S type is defined here. So that is basically the datum, the state itself and also the value. Remember I said that this would be represented, the state machine would be represented by a UTxO.}
{\pard  \line \par}
{So the state of the state machine is a UTxO, and that has a datum into value. So we have access to both in this state type. So given the state types, so the present datum and value of the UTxO and a transaction that tries to consume this UTxO with a redeemer I. We can indicate that this transition is not allowed by returning nothing in this function.}
{\pard  \line \par}
{And if it is allowed, we returned a tuple. And the second component is the new state. So this transaction will consume the existing UTxO and produce a new one at the same address. And this here will be the new datum and value of the new output, the new UTxO. And then we can have Tx constraints that until now we've only seen in off-chain code that specify additional constraints that the transaction that does this, that does this transition must have must satisfy.}
{\pard  \line \par}
{So that's the transition function. Then we have a function, just a predicate on datums basically on states that tells us whether it's a final state or not. So final states are special in debt in this transition function. If we transitioned into the, into a final state, Then there mustn't be any value attached with it.}
{\pard  \line \par}
{And then this output that normally gets produced. So we normally consume the UTxO representing the old state and produce a new output representing the new state. But if this new state is, is final, then we don't. So then we don't produce a new UTxO. So basically the machine instead stops. So that's this SM final, SM check is very similar to this transition function except it doesn't have the value.}
{\pard  \line \par}
{So it just gets the datum and the redeemer and context, and a reverse a bool. So this is basically an additional checks that can't be expressed in terms of these Tx constraints. Finally, we have this SM thread token, which can or cannot be there. And the purpose of this is to solve the same problem that we already had with our oracle in the last lecture.}
{\pard  \line \par}
{And also now with our game that as I have said many times before you can't stop anybody from sending anything to any arbitrary address. So there can be many UTxOs sitting at an address that you have no control over. But in cases like these, like the oracle last time or the game in the previous example, we want to identify a specific UTxO. }
{\pard  \line \par}
{And the trick we used in the last lecture and also just now was to mint and NFT and insist on it being present in the UTxO and because an NFT by definition can only exist once, this allows us to pinpoint the right UTxO and ignore other UTxOs that may sit at the same address. And the thread token here serves the same purpose.}
{\pard  \line \par}
{So if you look at thread token, it is basically a reference to a UTxO and the currency symbol and this UTxO will be the one that uniquely identifies the minting transaction of the NFT. So this is like a weird way to specify an NFT. So we don't have to use this mechanism, but if we use this, so if we put a just thread token there in the state machine, then the mechanism will automatically take care of minting.}
{\pard  \line \par}
{This NFT, that corresponds to this thread token, and then threading it through the state transitions. So in all these checks in validation will always make sure that the corresponding NFT is present in the UTxO and also if it's not the final state and there is a UTxO at the same address in the output that this NFT will then aslo be present in that output.}
{\pard  \line \par}
{So we don't have to worry about that. That will automatically be taken care of the minting and eventually burning in the final state of this NFT that corresponds to this thread token will be handled automatically. And it also doesn't appear in the value. So we sit here, the state bundles the datum and the value.}
{\pard  \line \par}
{And of course this NFT will be part of the value, but it won't be visible here. So we can ignore that, we don't have to worry about it. I have implemented the same game now using the state machine approach in module state machine. So the beginning is exactly the same. So the game parameter, the game type is exactly the same. }
{\pard  \line \par}
{Game choices the same, this is all the same. Game datum has slightly changed because I have added a second constructor that I called finished. That we didn't need before and that is supposed to represent the final state of our state machine. So it won't correspond to a UTxO, but we need that for the state machine mechanism to work.}
{\pard  \line \par}
{So this first construct is as before hash provided by the second player, maybe... sorry has provided by the first player. Maybe move by the second player and then this additional constructor to represent the final state that the game has ended. That makes a definition of equality slightly more complicated because now I have to take this second constructor into account as well.}
{\pard  \line \par}
{But nothing serious going on there, the redeemer is this exactly the same as before. These two helper functions are exactly the same as before. Now, this is now the transition function of the state machine, which sort of corresponds as we will see in a moment to the make game validator that we had earlier.}
{\pard  \line \par}
{So this is basically the core business logic. And so it takes the game, the parameter and now as we saw in the definition of state machine, state datum. So remember that's a pair basically consisting of the datum and the value. And the redeemer and then we must return nothing if it's not allowed and just a pair of new state and constraints on the transaction.}
{\pard  \line \par}
{Now let's try to compare the transition function of the state machine to the make game validator function of our first version of the game. So the first thing, I mean, of course the signature is different, but in spirit it's a very similar thing. So in both functions try to determine whether basically a combination of datum and redeemer and transaction is valid or not. So we we'll see the correspondence now. The first difference we notice is here in our old version, we first had to check that the input we are consuming, the UTxO we're consuming, actually carries the NFT, and that is missing in the state machine formulation because the state machine mechanism automatically takes care of that.}
{\pard  \line \par}
{If these set this last field in the state NFT to sub thread tokens, then the mechanism will automatically check that the NFT is present in the consumed UTxO and also in the newly created UTxO. If it's not a final state. So let's look at this first case where the first player moved. So the component for the second player was still nothing.}
{\pard  \line \par}
{And now the second player wants to make a play with choice C. So we checked these six conditions here and let's see how they are reflected in the state machine formulation. And in the state machine we have this, the state S which remember is a combination of datum and value, and you can access those two with state value and state data.}
{\pard  \line \par}
{So state value as is now the value in the UTxO that we're consuming state data S is the datum and R is the redeemer. So we have this triple. And here I checked that the value is actually the stake of the game. So the value contained in the consumed UTxO and that's the condition that was the second condition that we checked here.}
{\pard  \line \par}
{Now, the result of the transition function, if recall if it's valid, it's just the pair. And the first component of the pair is constraints on the transaction formulated using this constraints module that we know from off-chain code. And the second component of the pair is the new state of the resulting UTxO which again is given by datum and value.}
{\pard  \line \par}
{So here we are specifying with this transition of the second player makes a move. The new datum will be BS just C. And the new value will be twice this stake of the game because it's now the first player stake and the second player stake. We leave the NFT out of here, even though it should be present in the UTxO.}
{\pard  \line \par}
{And that is again, because the state machine implicitly takes care of that NFT that it's pass through. So we don't mention it here. So this here corresponds in the old one to this check that the datum is BS just C and that the value is right. This is this one here. And we don't need the last check, as I said. Here we check that the output again contains the NFT. We don't need that because the state machine does that automatically. So now what is missing? So here we have these two constraints must be signed by second and must validate in before the play deadline. And this corresponds here to the first condition must be signed by the second player.}
{\pard  \line \par}
{And the deadline thing is here. And if you check exactly all these conditions are covered here as well in slightly different form. An actually shorter form. And we don't have to worry about the NFT that already makes it shorter. Now let's look at the second interesting case where the second player has played and the first player sees that he has won. }
{\pard  \line \par}
{So now the first player has to reveal. So in the old version, we'll check it's signed by the first player. This is here. Then we check the nonce. That is no way here. And the reason is that that condition can't be expressed in terms of a constraint. And that is exactly what this other component of the record type of the state machine is for the check functions that we will see that in a bit.}
{\pard  \line \par}
{So this is missing for now. We don't have this nonce check. Then the deadline check is here. This just checks that the input value is right. So we have that here on the left-hand side. And finally, we check that because the game is over the NFT should go back to the first player. So that the game is over we specified here by specifying the finish state.}
{\pard  \line \par}
{And that the NFT goes back to the first player we don't need to check, because there's NFT and the state machine gets automatically taken care of. And gets burned when the state machine finishes reaches final state. So all we have to say is that we enter final state after that reveal has happened.}
{\pard  \line \par}
{Now, the third interesting case is the case where the second player doesn't react and the first player wants his stake back. So this is here. So let's see what we checked in the old quote. First of all, the transaction must be signed by the first player, and this is here, the first constraint. And secondly, the first clear must give the second player enough time to react.}
{\pard  \line \par}
{So he can only reclaim a stake after the play deadline has passed, so that's this condition. Then the incoming state must be correct, so the first player must have actually put down a stake. This is here on the left-hand side. And then finally, in the old code we wanted, the NFT goes back to the first player that has no equivalent here because that is taken care of automatically by the state machine mechanism.}
{\pard  \line \par}
{But we do transition into the finished states will be indicate that the game is over the state machine is finished. Finally, the fourth case. That is when the first player has played, the second player has played. And the first player realizes that he has lost and doesn't react anymore, or he gets disconnected.}
{\pard  \line \par}
{So in any case, the second player has won and can claim both his and the first player stake. So that must be signed by the second player. That's here. It must only happened after the reveal deadline has passed. That's here. And the incoming state must be correct. It must be both the first and the second player stake it's again, here, checked on the left-hand side.}
{\pard  \line \par}
{And again, this is a final state. So in the old version we insist the NFT goes back to the first player. This would be taken care of automatically here. We just indicate that we are transitioning into the finished state. Okay. And these are the valid transaction, these four transitions and everything else is invalid.}
{\pard  \line \par}
{And we indicate that by returning nothing in all other cases. So that means only those transitions are valid. So the conditions themselves are maybe not really shorter than in the old version, but we don't need any helper functions. So this, in our own input own output and so on, we don't need, this is all taken care of by the state machine or by these constraints.}
{\pard  \line \par}
{And we don't need to worry about the NFT. That's also automatically taken care of. So this is already significantly shorter than in the old version, but we are not done yet defining the state machine. There are other fields in the record. One is final. So we must specify what final states are and that's just this finished state.}
{\pard  \line \par}
{So final finished is true and everything else is false. Then we left out the nonce check in the transition function because we couldn't express that as a constraint. And for that's exactly what this check function is for. Then we have have two auxiliary arguments, these two byteStrings that we also had in the other version zero and one, for the same reason, we need that here.}
{\pard  \line \par}
{And then datum and redeemer and context and much just return whether this additional check is satisfied. We ignore the context, we don't need it here. And the only condition we have to put into this check function is the one with the nonce. And that wasn't the situation where the second player had played, just see, and where the redeemer is reveal nonce.}
{\pard  \line \par}
{And this line here is just the old check we had in the first version as well. We compute the concatenation of the nonce and the byteString corresponding to the move, hash that, and compared with the originally provided hash. And all other situations we don't need an additional check and therefore can return true.}
{\pard  \line \par}
{Now we can define our state machine and we give, so for now it has these three parameters, the game, and these two auxiliary byteStrings, and it returns a state machine. And we just provide the four fields that we just defined. So transition game, that was the important one, and this final check, the additional check.}
{\pard  \line \par}
{And finally, the thread token, which we just take from, from the game value. Now there is machinery provided by the state machine to make a game, a validator. So what our old make game validated function can now be replaced by using the state machine and using the make validator game state machines. So gave them same machines is our state machine here.}
{\pard  \line \par}
{And there's a make validator function that turns that into something of this type, which is exactly the type we had before in our handwritten version. So this is similar to before, I mean, we had this other mechanism to bundle datum type and the redeemer type, the state machine... that's the same basically. So now our type gaming can just be state machine game datum, game redeemer.}
{\pard  \line \par}
{Our two strings and are provided a second version of game state machine, where we only have to specify the game and not these two strings and that won't work in on-chain code. So it doesn't have this inlinable pragma because of the literal strings here. But in off-chain code it works perfectly fine.}
{\pard  \line \par}
{And then we don't have to provide this two additional parameters. Now this is exactly as before. So the same boilerplate we had before. Except now this make game validator has been defined here using the state machine mechanism, instead of doing it explicitly. And a game address, game client, no, game address is the same. Game client is a new thing. Game client is a state machine client, and this is basically what we need to interact with state machine from our wallet, from our contract monad. If you look at the definition of state machine client, is here, it has two fields, a state machine instance and then this chooser.}
{\pard  \line \par}
{So the state machine instance it's again a record type with two fields and it has a state machine and the typed validator. And both of those, we already have defined. So we can make a state machine instance. So what's this chooser all about? Well, in general, if we don't use the thread token mechanism, the NFT mechanism, we could have several UTxOs sitting at the address of the state machine.}
{\pard  \line \par}
{And the chooser is a way to pick the right one. So in general, we will find a list of UTxOs, I mean, it's a different type, the on chain state that, but you can think UTxOs sitting at the state machine address. And this chooser function given such a list, picking one. So either producing error.}
{\pard  \line \par}
{Or picking one of those, but there's a default implementation for such a chooser, which if we use the thread token mechanism just picks the one UTxO that holds this thread token. So in order to make a state machine client, we can use the make state machine client function, which just takes a state machine instance.}
{\pard  \line \par}
{So not a chooser because the default chooser will be used. So to make our game client given a game. We can just use this make state machine client. And now we need the state machine instance. And we must provide the state machine for which we can use our game state machine prime with the game as parameter. And the type game validator we also have to find here. So this gives us our game client. And now the client can be used to interact with the state machine from off-chain code. First parameters are exactly the same. There's one small nuisance that these state machine contracts, that the state machine module provides. They use a specific error type or they have a specific constraint on the error type.}
{\pard  \line \par}
{And one error type that works is SM contract error. But I want to do what I did in the last lectures and always use text as map error type. So in order to make those two fit together, I define this map error prime function, which use the map error we have discussed before. And it turns an SM contract error into a text by showing the SM contract error and then picking the resulting string into a text.}
{\pard  \line \par}
{I also, again, have this helper function wait until time has passed that I already used in the even odd the example, which given a time first waits until this time is reached and then waits for another slot to make sure we are in the slot after this time. Now the first game becomes much nicer, much shorter, much more compact.}
{\pard  \line \par}
{It starts the same. So we lookup our own public key hash. Now there's something new. We need to get this thread token. So we must identify a UTxO in our wallet that can be used for the minting of the NFT to make that a true NFT as I explained in the lecture on native tokens and NFTs. So that's what this get thread token function does.}
{\pard  \line \par}
{And I have to apply the map ever prime in order to convert it to text error messages, as I explained. And there's in the documentation for this get thread token it says you mustn't do any transactions after you have invoked that before you use it for a state machine, because that could change the UTxOs in your wallet.}
{\pard  \line \par}
{So then the situation could change. Okay, so now we have our public key hash, in our thread token, and we can define the game using public key hash and thread token at the appropriate spots. And taking the rest from the parameters we got. Now we can define our game client using the game client function. These three are as before.}
{\pard  \line \par}
{So it's the stake, our choice and the hash that we reveal that we commit to, that we use to commit to our move. And now in this one line, a lot happens under the hood. So this run initialise given the client, a datum and the value. First, it will mint the NFT corresponding to this thread token. And then it will create a UTxO at the state machine address to start the state machine. Put the NFT in that UTxO to uniquely identify it, and the datum and value of that UTxO are given by these arguments here.}
{\pard  \line \par}
{So we put it in the initial state we want whether first player commits using this hash. And the second player hasn't moved yet. And the first player puts down his stake. And again, we have to use the map error prime in order to adjust the error messages. And we just log that we made the first move.}
{\pard  \line \par}
{Now, this is also new. And if you look at the type, this has also slightly changed. Earlier, I didn't use the tell mechanism, the writer mechanism of the contract monad. Now, I need to communicate the thread token. Because the second player wants to find the game. So the second player must define this game. And part of that game is this thread token.}
{\pard  \line \par}
{So the second player otherwise would have no way of knowing what the thread token is. So in order to communicate that, I tell it here. Okay, so this is all to set it up. And now if you recall, we have to wait and then we needed this helper functions find game datum or game output in order to after we have waited for the second player to move, to find the UTxO again. This is now much simpler, because we can use something called get on-chain state.}
{\pard  \line \par}
{So get on-chain state takes the client and returns something of type maybe on-chain state. So if it finds the state machine, then it will return just on-chain state and if not, then nothing. So what is on-chain state? On-chain state is a tuple. Consisting of typed script Tx out and typed script Tx out ref.}
{\pard  \line \par}
{This is similar to what this UTxO at gives us. I mean, there we always got this map from orefs to Os from Tx out refs to Tx outs. And this is similar, it's also basically the UTxO itself and the reference to it. But it has this typed, it's this typed version that we have seen before.}
{\pard  \line \par}
{And all that does is, it basically bundles what we know from before, this Tx out. But additionally it provides the datum. If you recall, we always in our off-chain code, we always had to scramble and write helper functions to access the datum once we had found a UTxO. We had to lookup the datum hash and that could fail, and then we had to lookup the datum to this hash and so on. And all of this is basically hidden from us by using this typed script Tx out type. Which we get by using this get on-chain state. So by using get on-chain state client, we have this M and this M it could be nothing if no output is found as before, this should never happen.}
{\pard  \line \par}
{But if it does, we throw an error and now we get this on-chain state. We are not interested in the reference only in the o itself. And then we use this tyTx out data o to directly access the datum. So no need to lookup hashes, that's all, some wrapped in this tyTx out data. So now we immediately have the datum.}
{\pard  \line \par}
{And as before we have the two cases that the second player hasn't moved or that the test moved. So if it hasn't moved we must reclaim an earlier than we had lots of code to set up the lookups and the constraints that we need. Now, we only need this line. So the important function here is run step. So run step creates a transaction and submits it, that will transition the state machine. }
{\pard  \line \par}
{And it takes us input the client again. And then simply the redeemer, that's all, all the input we need is the redeemer. And then we will get this transition result and I'm not using it in this example, but that basically encodes whether it failed and for what reason it failed or whether it succeeded and if it succeeded what the new state is, but I don't really need this in, in this example.}
{\pard  \line \par}
{So this is all, this is really dramatically simpler. So all I have to do is I tell it, okay, in this case, the first player... the second player hasn't moved, I just do a step with the claim first redeemer. No constraints, no lookups, no submissions or waiting. This is all ended by the run step. And this is really need, I think. }
{\pard  \line \par}
{This is dramatically simpler than before. And the way it works of course, is that in the transition function. These conditions use these constraints. So all the constraints are available to the state machine mechanism, and that allows it to handle all of this automatically and to automatically assemble the compose the transaction that is needed.}
{\pard  \line \par}
{So this is where the state machine approach really, really plays out. So basically it's just this one line. And in the other case where the second player has moved, and if you think we won or if we know we won again, now we have to reveal and it's just this one line. So again, run step client with the reveal FP nonce FP redeemer, that's all, no constraints, no lookups nothing. }
{\pard  \line \par}
{So this is much much simpler now. And we don't need any helper functions as we did before. And same for the second player, it's just as short. So a second game, the beginning is the same. We lookup the public key hash. We define our game parameter, we defined the state machine client.}
{\pard  \line \par}
{Then we use this get on-chain state again to check the or the, UTxO that represents the state machine, represents the game. If we don't find it, that means no game is running. If you do find it all this other piece of information we could use, we don't need only the o. And again, we use this typed version to grab the datum and this case would mean that we haven't played yet.}
{\pard  \line \par}
{So now we should play and other cases are unexpected. So we expect that we can play and in order to play, again, it's just one line of code. We use run step and then the play, our choice redeemer. And we wait as before until the reveal deadline has passed. We again, check the new state. And now if there is none, that means the first player has won.}
{\pard  \line \par}
{So we don't do anything. But if there is something that means the first player hasn't won, and again, just one line of code to claim our win. And that's it. So here it really shines the state machine approach. It was already, I think, a bit shorter here in the on-chain code, a bit more concise we needed particularly we needed less helper functions.}
{\pard  \line \par}
{We didn't have to worry about this handling of the own input own output and of the NFT that it's passed through. But in the off-chain code it's really dramatically simpler now and much more readable. And the rest is exactly the same, it's just copy paste it. And what is particularly nice about the state machine approaches is that we don't have to replicate logic anymore.}
{\pard  \line \par}
{I mean, earlier I explained that the on-chain validation checks whether a transaction is valid, whereas the off-chain code has to construct a transaction that then will pass these checks that validation does. So on-chain and off-chain logic has slightly different purposes. On chain has to check, whereas off-chain has to construct. But by using this trick to specify the state machine using the constraints, that can be used for both for checking and for construction.}
{\pard  \line \par}
{We now don't have to replicate this logic anymore. So we only use the constraints and they can be used to construct the transaction, but also to check the transaction. So in principle we have the amount of code we need to write. And we removed a lot of duplication. In order to test this, I create this module tests, state machine, and it's almost an exact copy of the test module we saw earlier.}
{\pard  \line \par}
{There's one small wrinkle. First of all, of course, instead of importing even on time now importing state machine. But then there's one other difference. And that is with the deadlines. Earlier I use slot to begin POSIX time, and now I'm using end and that is due to a back in the state machine library.}
{\pard  \line \par}
{And that has to do with this thing I mentioned, I think two lectures ago already that the underlying transactions use slots not POSIX time. So when you go from off-chain to on-chain code, you have to convert the validity intervals into slots, and then back into POSIX times. And because slots have a smaller granularity. So I mean, one slot is one second. You can't faithfully convert back and forth, and that leads to problems. So what I said earlier about constraints that they self this dual purpose of specifying validation in the on-chain part and constructing transactions in the off-chain part. This unfortunately at the moment is not true due to this problem with a conversion.}
{\pard  \line \par}
{So, if you're not careful, if you use a POSIX time that lies at the beginning of a slot, then the transaction that the state machine produces won't validate. And I hope that will be fixed soon, but for the time being, we can work around that by using POSIX times that lie at the end of a slot. So I had to change that, but everything else should be exactly the same.}
{\pard  \line \par}
{And if we try it out in the repl, then we should get exactly the same result that we got before. But with now using state machines. So state machines are not always appropriate. But when they are, you should definitely use them because they dramatically reduce the amount of code you have to write and also remove sources of error because you avoid code duplication, basically the state machine automatically takes care of guaranteeing that the on-chain and the off-chain code fit together. So the off-chain code will produce transactions that then will be validated by the on-chain code. And until now we always had to take care of that by hand. So big source of errors or backs is removed and everything is much shorter. Because a lot of the machinery to find, to identify the right UTxO and to pass through the state token is taken care of for you automatically by the state machine mechanism. Of course it's not always appropriate, but when you have this module... model that there's basically one specific UTxO that carries some state in its datum and that transition.}
{\pard  \line \par}
{So there are transactions that consume this UTxO and produce a new one at the same address with the possibly updated datum and value. Then you should definitely ask yourself whether you can model that as a state machine and then use this state machine mechanism. }
{\pard  \line \par}
{\b\fs36 [01:21:13] 0705 Homework\b0}
{\pard  \line \par}
{For homework. I recommend that you modify this state machine module and implement the rock paper scissors game instead of this game we implemented. And so the game definition can stay exactly the same, but then for choices instead of zero one, we have three choices, rock paper, and scissors. And then the implementation of equality changes, of course, rock equals rock, paper equals paper, scissors equals scissors, nothing else equals anything else.}
{\pard  \line \par}
{And I suppose it will be helpful to implement a beats function that takes two of these choices and then says whether the first one beats the second. So rock beats scissors, paper beats rock, and scissors beat paper, and that's all. And I want you to reimplement the game with these additional options.}
{\pard  \line \par}
{So a lot is very similar. The only difference of course is that now there's also the possibility of a draw if both players make the same move. And in that case, of course, this state should be split. So each player should get his or her own stake back. There's one more change you need to make to the redeemer type.}
{\pard  \line \par}
{Earlier, in the reveal case, we only had to provide the nonce. We didn't have to provide the actual move that the first player made, because he would only reveal if he won. So if he made the same move that the second player made. So this was redundant information and we didn't need it, but now we do need it because there are two possibilities, what the first player could have done.}
{\pard  \line \par}
{If he knows he lost, he won't reveal. But he could reveal if he won, but also if it's a draw, because if he doesn't reveal, even if it's a draw, then the second player would get everything. So the first player now must reveal if he won or if it was a draw. So in order to write down the correct conditions, we now need the choice that the first player made.}
{\pard  \line \par}
{And with that you need one more case in the transition function to take care of this draw case. And there are some slight modifications. For example, now you need three of these byteStrings instead of zero one, you need three choices for how to represent rock paper scissors. And also in the off-chain code there's a slight change when you check what to do if there's a draw. But everything is very similar. So there are not a lot of changes needed.}
}